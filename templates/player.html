<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Player - HLS Proxy</title>
    <!-- hls.js -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        html {
            height: 100%;
        }

        :root {
            --bg-primary: #0f0f23;
            --bg-secondary: #1a1a2e;
            --surface: rgba(255, 255, 255, 0.05);
            --surface-glass: rgba(255, 255, 255, 0.08);
            --surface-elevated: rgba(255, 255, 255, 0.12);
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --accent-success: #10b981;
            --border-primary: rgba(255, 255, 255, 0.1);
            --border-accent: rgba(255, 255, 255, 0.2);
            --glow-primary: 0 0 20px rgba(99, 102, 241, 0.3);
            --glow-secondary: 0 0 30px rgba(139, 92, 246, 0.4);
            --text-primary: #ffffff;
            --text-secondary: #a1a1aa;
            --text-muted: #71717a;
            --border-radius: 16px;
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
            --spacing-xl: 2rem;
            --transition-normal: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100%;
            overflow-x: hidden; /* Changed from overflow: hidden */
            position: relative; /* Added for pseudo-element positioning */
        }

        /* Animated Background from builder.html */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 20% 50%, rgba(99, 102, 241, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(139, 92, 246, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(6, 182, 212, 0.15) 0%, transparent 50%);
            animation: backgroundFloat 25s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes backgroundFloat {
            0%, 100% {
                transform: translateY(0) rotate(0deg) scale(1);
            }
            33% {
                transform: translateY(-20px) rotate(1deg) scale(1.02);
            }
            66% {
                transform: translateY(20px) rotate(-1deg) scale(0.98);
            }
        }

        .container {
            max-width: 1400px;
            margin: auto;
            padding: var(--spacing-lg);
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .header {
            text-align: center;
            margin-bottom: var(--spacing-lg);
        }

        .page-title {
            font-size: 2.5rem;
            background: linear-gradient(90deg, #00f5ff, #ff00ff, #ffff00, #ff00ff, #00f5ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradient 5s infinite;
        }

        @keyframes gradient {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        .player-layout {
            display: grid;
            grid-template-columns: 1fr 500px;
            gap: var(--spacing-lg);
            flex-grow: 1;
            min-height: 0;
        }

        @media(max-width:1024px) {
            .player-layout {
                grid-template-columns: 1fr;
            }
        }

        .player-section {
            background: var(--surface-glass);
            border: 1px solid var(--border-primary);
            border-radius: var(--border-radius);
            padding: var(--spacing-lg);
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow-y: auto;
        }

        .input-group {
            display: flex;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
        }

        .playlist-input {
            flex: 1;
            padding: var(--spacing-md) var(--spacing-lg);
            background: var(--surface);
            border: 1px solid var(--border-primary);
            border-radius: var(--border-radius);
            color: var(--text-primary);
            font-size: 0.95rem;
            transition: var(--transition-normal);
        }

        .playlist-input:focus {
            outline: none;
            border-color: var(--accent-success);
            box-shadow: var(--glow-primary);
        }

        .proxy-toggle {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm) var(--spacing-md);
            background: var(--surface);
            border: 1px solid var(--border-primary);
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: var(--transition-normal);
            user-select: none;
        }

        .proxy-toggle:hover {
            background: var(--surface-elevated);
            border-color: var(--border-accent);
        }

        .proxy-toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
            background: var(--surface-elevated);
            border-radius: 12px;
            transition: var(--transition-normal);
        }

        .proxy-toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: var(--transition-normal);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .proxy-toggle.active .proxy-toggle-switch {
            background: var(--accent-success);
        }

        .proxy-toggle.active .proxy-toggle-switch::after {
            transform: translateX(20px);
        }

        .proxy-toggle-label {
            font-size: 0.9rem;
            font-weight: 500;
        }

        .load-button {
            padding: var(--spacing-md) var(--spacing-xl);
            background: var(--primary-gradient);
            border: none;
            border-radius: var(--border-radius);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition-normal);
        }

        .load-button:hover {
            transform: translateY(-2px);
            box-shadow: var(--glow-secondary);
        }

        .video-wrapper {
            position: relative;
            width: 100%;
            padding-top: 56.25%; /* 16:9 Aspect Ratio (9 / 16 * 100%) */
            /* flex: 1; and min-height: 0; removed as padding-top defines height */
            background: #000;
            border: 1px solid var(--border-primary);
            border-radius: var(--border-radius);
            overflow: hidden;
            margin-bottom: var(--spacing-lg);
        }
        


        #videoPlayer {
            width: 100%;
            height: 100%;
            position: absolute; /* Needed for aspect ratio hack */
            top: 0;
            left: 0;
        }
        .current-channel {
            padding: var(--spacing-md);
            background: var(--surface);
            border-radius: var(--border-radius);
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            border: 1px solid var(--border-primary);
        }

        .current-channel-logo {
            width: 48px;
            height: 48px;
            border-radius: 8px;
            object-fit: cover;
            background: var(--surface-elevated);
        }
        .current-channel-info-wrapper {
            flex: 1;
            min-width: 0;
        }

        .current-channel-desc {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 4px;
            max-height: 120px; /* Aumentato per piÃ¹ visibilitÃ  */
            overflow-y: auto;
            padding-right: var(--spacing-sm);
            word-wrap: break-word;
        }

        .channels-section h3 {
            font-size: 1.3rem;
            margin-bottom: var(--spacing-md);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            flex-shrink: 0;
        }

        .search-box {
            width: 100%;
            padding: var(--spacing-md);
            background: var(--surface);
            border: 1px solid var(--border-primary);
            border-radius: var(--border-radius);
            color: var(--text-primary);
            margin-bottom: var(--spacing-md);
            transition: var(--transition-normal);
            flex-shrink: 0;
        }

        .search-box:focus {
            outline: none;
            border-color: var(--accent-success);
            box-shadow: var(--glow-primary);
        }

        .channels-list {
            flex: 1;
            overflow-y: auto;
            padding-right: var(--spacing-sm);
            min-height: 0;
        }

        .channel-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            padding: var(--spacing-md);
            background: var(--surface);
            border: 1px solid var(--border-primary);
            border-radius: var(--border-radius);
            margin-bottom: var(--spacing-sm);
            cursor: pointer;
            transition: var(--transition-normal);
        }

        .channel-item:hover {
            background: var(--surface-elevated);
            border-color: var(--border-accent);
            transform: translateX(4px);
        }

        .channel-item.active {
            background: var(--accent-success);
            border-color: var(--accent-success);
        }

        .channel-logo {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            object-fit: cover;
            background: var(--surface-elevated);
            flex-shrink: 0;
        }

        .channel-info {
            flex: 1;
            min-width: 0;
        }

        .channel-name {
            font-weight: 600;
            font-size: 0.95rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .channel-group {
            font-size: 0.85rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .epg-info {
            font-size: 0.8rem;
            color: var(--accent-success);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 2px;
        }

        .epg-desc {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 4px;
        }

        /* Marquee effect CSS */
        .channel-name, .channel-group, .epg-info, .epg-desc {
            position: relative; /* Needed for transform */
        }

        @keyframes marquee-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(var(--scroll-distance)); }
        }

        .error-message {
            padding: var(--spacing-md);
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--accent-error);
            border-radius: var(--border-radius);
            color: #ef4444;
            margin-bottom: var(--spacing-md);
        }

        .empty-state {
            text-align: center;
            padding: var(--spacing-xl);
            color: var(--text-secondary);
        }

        #groupFilter option {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1 class="page-title">ðŸŽ¥ Web Player</h1>
            <p class="page-subtitle">Riproduci la tua playlist M3U/M3U8 custom</p>
        </div>
        <div class="player-layout">
            <div class="player-section">
                <div class="playlist-input-section">
                    <div class="input-group">
                        <input type="text" id="playlistUrl" class="playlist-input"
                            placeholder="Inserisci l'URL della playlist M3U/M3U8...">
                        <div class="proxy-toggle active" id="proxyToggle">
                            <div class="proxy-toggle-switch"></div><span class="proxy-toggle-label">Proxy</span>
                        </div>
                        <button id="loadPlaylistBtn" class="load-button">Carica</button>
                    </div>
                    <div id="errorContainer"></div>
                </div>
                <div class="video-wrapper">
                    <video id="videoPlayer" controls preload="auto"></video>
                </div>
                <div id="currentChannelInfo" style="display:none;">
                    <div class="current-channel">
                        <img id="currentChannelLogo" class="current-channel-logo" src="" alt="">
                        <div class="current-channel-info-wrapper">
                            <h3 id="currentChannelName" class="channel-name"><span class="marquee-text"></span></h3>
                            <div id="currentEpgInfo">
                                <p id="currentChannelEpgTitle" style="font-weight: 600; color: var(--accent-success); margin-top: 4px;"></p>
                                <p id="currentChannelEpgDesc" class="current-channel-desc"></p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="player-section channels-section">
                <h3><span>ðŸ“º</span><span>Canali</span><span id="channelCount"
                        style="margin-left:auto;font-size:0.9rem;color:var(--text-secondary);"></span></h3>
                <div class="filters-container" style="display: flex; gap: var(--spacing-md); margin-bottom: var(--spacing-md);">
                    <select id="groupFilter" class="search-box" style="display:none; flex: 1;"></select>
                    <input type="text" id="searchBox" class="search-box" placeholder="ðŸ” Cerca canale..."
                        style="display:none; flex: 2;">
                </div>
                <div id="channelsList" class="channels-list">
                    <div class="empty-state">
                        <p>Carica una playlist per visualizzare i canali</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script>
        let hls;
        let video;
        let channels = [];
        let currentEpgUrls = [];
        let useProxy = true;
        let eventListeners = new WeakMap(); // Per tenere traccia dei listener

        document.addEventListener('DOMContentLoaded', () => {
            video = document.getElementById('videoPlayer');
            if (Hls.isSupported()) {
                hls = new Hls({
                    // Configurazione di hls.js per maggiore robustezza
                    maxMaxBufferLength: 120, // Aumenta il buffer massimo
                    fragLoadingMaxRetry: 6,   // Aumenta i tentativi di caricamento dei frammenti
                    levelLoadingMaxRetry: 4,  // Aumenta i tentativi di caricamento dei livelli di qualitÃ 
                });
                hls.attachMedia(video);
            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                // Fallback per browser con supporto HLS nativo (es. Safari)
                console.log("HLS.js non supportato, si utilizza il player nativo.");
            } else {
                showError("Il tuo browser non supporta lo streaming HLS.");
            }
            
            // Attach event listeners
            document.getElementById('loadPlaylistBtn').addEventListener('click', loadPlaylist);
            document.getElementById('playlistUrl').addEventListener('keypress', e => { if (e.key === 'Enter') loadPlaylist(); });
            document.getElementById('searchBox').addEventListener('input', filterChannels);
            document.getElementById('groupFilter').addEventListener('change', filterChannels);
            document.getElementById('proxyToggle').addEventListener('click', function () { 
                useProxy = !useProxy; 
                this.classList.toggle('active'); 
            });

            // Imposta la playlist di default e carica l'ultima usata se presente
            const defaultPlaylistUrl = 'https://raw.githubusercontent.com/nzo66/TV/refs/heads/main/lista.m3u';
            const lastUrl = localStorage.getItem('lastPlaylistUrl');
            const urlToLoad = lastUrl || defaultPlaylistUrl;

            document.getElementById('playlistUrl').value = urlToLoad;
            loadPlaylist();
        });
        async function loadPlaylist() {
            const url = document.getElementById('playlistUrl').value.trim();
            const err = document.getElementById('errorContainer');
            const btn = document.getElementById('loadPlaylistBtn');
            const channelsList = document.getElementById('channelsList');
            const searchBox = document.getElementById('searchBox');
            const channelCount = document.getElementById('channelCount');

            // Reset UI
            err.innerHTML = '';
            channelsList.innerHTML = '<div class="empty-state"><p>Caricamento in corso...</p></div>';
            searchBox.style.display = 'none';
            channelCount.textContent = '';

            if (!url) {
                showError('Inserisci un URL valido');
                channelsList.innerHTML = '<div class="empty-state"><p>Carica una playlist per visualizzare i canali</p></div>';
                return;
            }

            btn.disabled = true;
            btn.textContent = 'Caricamento...';

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30-second timeout

            try {
                const resp = await fetch(`/api/parse-playlist?url=${encodeURIComponent(url)}`, { signal: controller.signal });
                clearTimeout(timeoutId);

                if (!resp.ok) throw new Error(`Errore HTTP: ${resp.status}`);

                const data = await resp.json();
                if (data.error) throw new Error(data.error);

                channels = data.channels || [];
                currentEpgUrls = data.epg_urls || [];

                if (channels.length === 0) {
                    showError('Nessun canale trovato o playlist non valida.');
                    channelsList.innerHTML = '<div class="empty-state"><p>Nessun canale trovato</p></div>';
                    return;
                }

                // Load EPG data first, then display channels
                if (currentEpgUrls.length > 0) {
                    await fetchAllEpg();
                }

                displayChannels(channels);

                // Populate group filter
                const groupFilter = document.getElementById('groupFilter');
                const groups = [...new Set(channels.map(c => c.group).filter(g => g))];
                groupFilter.innerHTML = '<option value="">Tutti i gruppi</option>';
                groups.forEach(g => {
                    const option = document.createElement('option');
                    option.value = g;
                    option.textContent = g;
                    groupFilter.appendChild(option);
                });

                searchBox.style.display = 'block';
                groupFilter.style.display = 'block';
                channelCount.textContent = `${channels.length} canali`;

            } catch (e) {
                console.error(e);
                if (e.name === 'AbortError') {
                    showError('Errore: Timeout. Il server ha impiegato troppo tempo per rispondere.');
                } else {
                    showError(`Errore: ${e.message}`);
                }
                channelsList.innerHTML = '<div class="empty-state"><p>Caricamento fallito</p></div>';
            }
            finally {
                btn.disabled = false;
                btn.textContent = 'Carica';
            }
        }
        function displayChannels(list) {
            const container = document.getElementById('channelsList');
            if (list.length === 0) { container.innerHTML = '<div class="empty-state"><p>Nessun canale trovato</p></div>'; return; }
            container.innerHTML = list.map(ch => {
                const originalIndex = channels.findIndex(originalCh => originalCh.url === ch.url && originalCh.name === ch.name);
                return `
                <div class="channel-item" onclick="playChannel(${originalIndex})">
                    <img class="channel-logo" src="${ch.logo || 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 24 24%22 fill=%22%23666%22%3E%3Cpath d=%22M21 3H3c-1.11 0-2 .89-2 2v12a2 2 0 0 0 2 2h5v2h8v-2h5c1.1 0 1.99-.9 1.99-2L23 5a2 2 0 0 0-2-2zm0 14H3V5h18v12zm-5-6l-7 4V7z%22/%3E%3C/svg%3E'}" alt="${ch.name}" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 24 24%22 fill=%22%23666%22%3E%3Cpath d=%22M21 3H3c-1.11 0-2 .89-2 2v12a2 2 0 0 0 2 2h5v2h8v-2h5c1.1 0 1.99-.9 1.99-2L23 5a2 2 0 0 0-2-2zm0 14H3V5h18v12zm-5-6l-7 4V7z%22/%3E%3C/svg%3E'"/>
                    <div class="channel-info">
                        <div class="channel-name"><span class="marquee-text">${escapeHtml(ch.name)}</span></div>
                        ${ch.group ? `<div class="channel-group"><span class="marquee-text">${escapeHtml(ch.group)}</span></div>` : ''}
                        ${ch.epg && ch.epg.title ? `<div class="epg-info">ðŸ“º <span class="marquee-text">${escapeHtml(ch.epg.title)}</span></div>` : ''}
                        ${ch.epg && ch.epg.desc ? `<div class="epg-desc"><span class="marquee-text">${escapeHtml(ch.epg.desc)}</span></div>` : ''}
                    </div>
                </div>`;
            }).join('');

            applyMarqueeEffects(); // Call it after rendering channels
        }

        function fetchAllEpg() {
            return fetch('/player/epg/all', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ epg_urls: currentEpgUrls })
            })
            .then(response => {
                if (response.ok) {
                    return response.json();
                }
                throw new Error('Failed to fetch EPG');
            })
            .then(epgData => {
                return new Promise(resolve => {
                    // Process EPG data in small batches to avoid blocking UI
                    let index = 0;

                    function processBatch() {
                        const startTime = Date.now();
                        while (index < channels.length && (Date.now() - startTime < 10)) { // Process for max 10ms per batch
                            const ch = channels[index];
                            if (ch.id && epgData[ch.id]) {
                                ch.epg = { title: epgData[ch.id].title, desc: epgData[ch.id].description };
                            }
                            index++;
                        }
                        if (index < channels.length) { setTimeout(processBatch, 0); } 
                        else { resolve(); }
                    }
                    setTimeout(processBatch, 0);
                });
            })
            .catch(e => {
                console.error("Error fetching all EPG data:", e);
                return Promise.resolve(); // Resolve even on error to not block
            });
        }

        function filterChannels() {
            const searchTerm = document.getElementById('searchBox').value.toLowerCase();
            const selectedGroup = document.getElementById('groupFilter').value;

            let filtered = channels;

            // 1. Filter by selected group
            if (selectedGroup) {
                filtered = filtered.filter(c => c.group === selectedGroup);
            }

            // 2. Filter by search term (name or group)
            if (searchTerm) {
                filtered = filtered.filter(c =>
                    c.name.toLowerCase().includes(searchTerm) ||
                    (c.group && c.group.toLowerCase().includes(searchTerm))
                );
            }

            displayChannels(filtered);
        }

        async function playChannel(idx) {
            if (idx < 0 || idx >= channels.length) return;
            const ch = channels[idx];

            let streamUrl;
            if (useProxy) {
                // âœ… CORREZIONE: Costruisce l'URL del proxy in modo dinamico.
                // 1. Inizia con l'URL base dello stream.
                streamUrl = `/proxy/manifest.m3u8?url=${encodeURIComponent(ch.url)}`;

                // 2. Se il canale ha una 'clearkey', la aggiunge come parametro separato.
                if (ch.clearkey) {
                    streamUrl += `&clearkey=${encodeURIComponent(ch.clearkey)}`;
                }
            } else {
                streamUrl = ch.url;
            }

            if (hls) {
                hls.loadSource(streamUrl);
                hls.once(Hls.Events.MANIFEST_PARSED, function () {
                    video.play();
                });
            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                // Per supporto nativo
                video.src = streamUrl;
                video.addEventListener('loadedmetadata', function () {
                    video.play();
                });
            }

            document.getElementById('currentChannelInfo').style.display = 'block';
            const currentChannelNameContainer = document.getElementById('currentChannelName');
            const currentChannelNameSpan = currentChannelNameContainer.querySelector('.marquee-text');
            currentChannelNameSpan.textContent = ch.name;
            

            const epgTitleElement = document.getElementById('currentChannelEpgTitle');
            const epgDescElement = document.getElementById('currentChannelEpgDesc');

            epgTitleElement.textContent = 'Caricamento EPG...';
            epgDescElement.textContent = '';

            const logo = document.getElementById('currentChannelLogo');
            if (ch.logo) { logo.src = ch.logo; logo.style.display = 'block'; } else { logo.style.display = 'none'; }

            // Deactivate all channel items first
            document.querySelectorAll('.channel-item').forEach(el => el.classList.remove('active'));

            // Find the specific item in the currently displayed list and activate it
            const activeItem = document.querySelector(`.channel-item[onclick="playChannel(${idx})"]`);
            if (activeItem) {
                activeItem.classList.add('active');
                activeItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            // Fetch EPG if available
            if (ch.id && currentEpgUrls.length > 0) {
                try {
                    const response = await fetch('/player/epg', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            epg_urls: currentEpgUrls,
                            tvg_id: ch.id
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        epgTitleElement.textContent = data.title;
                        epgDescElement.textContent = data.description;

                        // Update channel object
                        ch.epg = { title: data.title, desc: data.description };
                    } else {
                        epgTitleElement.textContent = 'Nessuna informazione EPG disponibile';
                        epgDescElement.textContent = '';
                    }
                } catch (e) {
                    console.error("Error fetching EPG:", e);
                    epgTitleElement.textContent = 'Errore caricamento EPG';
                    epgDescElement.textContent = '';
                }
            } else {
                epgTitleElement.textContent = 'Nessuna informazione EPG disponibile';
                epgDescElement.textContent = '';
            }
        }
        function showError(msg) { document.getElementById('errorContainer').innerHTML = `<div class="error-message">${escapeHtml(msg)}</div>`; }
        function escapeHtml(t) { const d = document.createElement('div'); d.textContent = t; return d.innerHTML; }

        function applyMarqueeEffects() {
            const containers = document.querySelectorAll('.channel-name, .channel-group, .epg-info, .epg-desc');
            
            containers.forEach(container => {
                // Rimuovi i vecchi listener se esistono
                if (eventListeners.has(container)) {
                    const { enter, leave } = eventListeners.get(container);
                    container.removeEventListener('mouseenter', enter);
                    container.removeEventListener('mouseleave', leave);
                    eventListeners.delete(container);
                }

                const textSpan = container.querySelector('.marquee-text');
                if (!textSpan) return;

                const parentWidth = container.offsetWidth;
                const textWidth = textSpan.scrollWidth;

                if (textWidth > parentWidth) {
                    const handleMouseEnter = () => {
                        const span = container.querySelector('.marquee-text');
                        if (!span) return;
                        const scrollDistance = parentWidth - textWidth - 5; // -5 for slight padding
                        const duration = Math.abs(scrollDistance / 50) + 2; // Speed up based on distance, min 2s
                        span.style.setProperty('--scroll-distance', `${scrollDistance}px`);
                        span.style.animation = `marquee-scroll ${duration}s linear forwards`;
                        container.style.textOverflow = 'clip'; // Remove ellipsis during scroll
                    };

                    const handleMouseLeave = () => {
                        const span = container.querySelector('.marquee-text');
                        if (!span) return;
                        span.style.animation = '';
                        span.style.transform = ''; // Reset position
                        container.style.textOverflow = 'ellipsis'; // Restore ellipsis
                    };

                    container.addEventListener('mouseenter', handleMouseEnter);
                    container.addEventListener('mouseleave', handleMouseLeave);
                    eventListeners.set(container, { enter: handleMouseEnter, leave: handleMouseLeave });
                }
            });
        }

    </script>
</body>

</html>
